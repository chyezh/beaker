use super::{Error, Result};
use crate::cmd::Command;
use crate::engine::DB;
use crate::resp::{Connection, Frame};
use crate::util::shutdown::Listener;
use tokio::io::{AsyncRead, AsyncWrite};

// Process a connection sequentially.
// 1. Transfer connection frame into command
// 2. Send command to DB engine
// 3. Transfer result of command into frame and write to connection.
pub struct Handler<T> {
    db: DB,
    conn: Connection<T>,
    shutdown: Listener,
}

impl<T: AsyncRead + AsyncWrite + Unpin> Handler<T> {
    // Create a new handler with given db engine and connection
    pub fn new(db: DB, conn: Connection<T>, shutdown: Listener) -> Self {
        Handler { db, conn, shutdown }
    }

    // Run this Handler
    pub async fn run(&mut self) -> Result<()> {
        loop {
            tokio::select! {
                // Exit handling loop if server was request to shutdown
                _ = self.shutdown.listen() => {
                    break;
                }
                frame = self.conn.read_frame() => {
                    let frame = frame?;
                    self.handle_single_frame(frame).await?;
                }
            };
        }

        Ok(())
    }

    async fn handle_single_frame(&mut self, frame: Option<Frame>) -> Result<()> {
        let frame = match frame {
            Some(Frame::Array(f)) => f,
            Some(_) => return Err(Error::UnexpectedDataFrame), // Unexpected resp frame
            None => return Ok(()), // Operation finished, connection closed by peer
        };

        // Parse command and apply command
        let cmd = Command::from_frame(frame.into_iter())?;

        // Apply command into db engine
        // Any database error is recoverable for this connection,
        // otherwise any network IO error is unrecoverable
        match apply(cmd, self.db.clone()).await {
            Ok(response) => {
                self.conn.write_frame(&response).await?;
            }
            Err(err) => {
                // Send error if error happened in apply function
                self.conn
                    .write_frame(&Frame::Error(err.to_string()))
                    .await?;
            }
        }
        // Flush the response was already written
        self.conn.flush().await?;
        Ok(())
    }
}

// Apply command to db engine, and write result of command into connection
// All error was generated by underlying database engine
async fn apply(cmd: Command, db: DB) -> Result<Frame> {
    Ok(match cmd {
        Command::Get(get) => {
            let val = db.get(get.raw_key()).await?;
            get.response(val)
        }
        Command::Ping(ping) => ping.response(),
        Command::Set(set) => {
            db.set(set.key(), set.val())?;
            set.response()
        }
        Command::Del(del) => {
            db.del(del.key())?;
            del.response()
        }
    })
}
